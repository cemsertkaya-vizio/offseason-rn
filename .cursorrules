# React Native Fitness App - Cursor Rules

## Project Overview
This is a React Native fitness application (OffseasonApp) with TypeScript, targeting both iOS and Android platforms.

## Technology Stack
- React Native with TypeScript
- React Navigation for routing
- Jest for testing
- Native iOS (Swift) and Android (Kotlin) modules

## Code Organization

### File Structure
- `/src/components` - Reusable UI components
- `/src/screens` - Screen-level components
- `/src/navigation` - Navigation configuration
- `/src/constants` - App-wide constants (colors, theme, etc.)
- `/src/types` - TypeScript type definitions
- `/src/assets` - Images, fonts, and other static assets

### Component Conventions
- Use functional components with React Hooks
- Export components from index.ts files in each folder
- Keep components under 200-300 lines; refactor if exceeding this
- Component files should be named in PascalCase with .tsx extension
- One component per file

### Naming Conventions
- Components: PascalCase (e.g., `TextInput.tsx`, `RegisterScreen.tsx`)
- Files/folders: camelCase or PascalCase for components, lowercase with hyphens for configs
- Constants: SCREAMING_SNAKE_CASE for true constants, camelCase for objects
- Types/Interfaces: PascalCase with descriptive names

## React Native Specific

### Component Structure
- Always import React explicitly
- Use TypeScript interfaces for props
- Define prop types above the component
- Use destructuring for props
- Prefer const for functional components

### Styling
- Use StyleSheet.create for styles
- Define styles at the bottom of the component file
- Use constants from `/src/constants/colors.ts` for colors
- Never hardcode colors, spacing, or dimensions that might be reused
- Follow responsive design principles using Dimensions API when needed

### Navigation
- Use TypeScript with React Navigation
- Define navigation types in `/src/types/navigation.ts`
- Use typed navigation hooks (useNavigation, useRoute)
- Keep navigation logic in `/src/navigation` folder

### State Management
- Use React Hooks (useState, useEffect, useContext, etc.)
- Keep state as local as possible
- If state needs to be shared, use Context API or consider state management library

### Performance
- Use React.memo for components that render often with same props
- Use useMemo and useCallback to prevent unnecessary re-renders
- Optimize FlatList with proper keyExtractor and getItemLayout when possible
- Lazy load images and heavy components

## Fitness App Domain

### User Data Handling
- Always validate user input for fitness metrics (weight, reps, sets, etc.)
- Handle edge cases for measurements (imperial/metric conversions)
- Ensure workout data persistence and proper state management
- Consider offline-first architecture for workout tracking

### Health & Safety
- Add appropriate warnings for intense workouts
- Validate age and health data appropriately
- Never store sensitive health data without encryption
- Follow health data privacy regulations (HIPAA if applicable)

## TypeScript

### Type Safety
- Enable strict mode in tsconfig.json
- Avoid using `any` type; use `unknown` if type is truly unknown
- Define interfaces for all props, state, and data structures
- Use proper typing for async functions and promises
- Export types/interfaces that might be reused

### Type Organization
- Keep navigation types in `/src/types/navigation.ts`
- Create separate type files for complex domain models
- Co-locate simple types with their components if not reused

## Testing

### Test Requirements
- Write tests for business logic and utility functions
- Test critical user flows (authentication, workout tracking)
- Use React Native Testing Library for component tests
- Mock API calls and external dependencies
- Tests should be in `__tests__` folders or adjacent to files with .test.tsx extension

### Test Patterns
- Focus on user behavior, not implementation details
- Test accessibility labels and roles
- Mock navigation in screen tests
- Never mock data for dev or prod, only for tests

## Platform-Specific Code

### iOS (Swift)
- Keep native modules minimal and well-documented
- Use Swift conventions in AppDelegate and native modules
- Test iOS-specific features on actual devices when possible

### Android (Kotlin)
- Follow Kotlin conventions in native modules
- Handle Android permissions properly
- Test on various Android versions and screen sizes

## API & Networking

### API Calls
- Centralize API logic (consider creating /src/api or /src/services folder)
- Handle loading, error, and success states consistently
- Implement proper error handling with user-friendly messages
- Use TypeScript for request/response types
- Implement retry logic for failed requests when appropriate

### Authentication
- Securely store tokens (use react-native-keychain or similar)
- Implement proper token refresh logic
- Handle expired sessions gracefully

## Logging & Debugging

### Logging
- Always add class/component name to logs: `ComponentName - [event description]`
- Use appropriate log levels (console.log, console.warn, console.error)
- Remove or disable verbose logging in production builds
- Consider using a logging library for production

### Error Handling
- Implement error boundaries for graceful error handling
- Log errors with context for debugging
- Show user-friendly error messages
- Never expose sensitive info in error messages

## Assets & Resources

### Images
- Use appropriate image formats (PNG for transparency, JPEG for photos)
- Provide @2x and @3x variants for iOS
- Use appropriate densities for Android (mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi)
- Optimize images before adding to project
- Consider using react-native-fast-image for better performance

### Icons
- Use vector icons when possible (react-native-vector-icons)
- Keep icon sizes consistent across the app
- Use proper accessibility labels for icons

## Accessibility

### A11y Requirements
- Add accessibility labels to interactive elements
- Use proper semantic roles
- Test with screen readers (VoiceOver on iOS, TalkBack on Android)
- Ensure sufficient color contrast
- Support dynamic font sizing

## Version Control

### Commit Practices
- Write clear, descriptive commit messages
- Keep commits focused and atomic
- Never commit sensitive data (.env files, keys, credentials)
- Update README when adding new features or changing setup

## Environment Management

### Environment Variables
- Use separate configurations for dev, staging, and prod
- Never overwrite .env files without explicit confirmation
- Keep sensitive keys out of version control
- Document all required environment variables

## Code Quality

### General Principles
- Follow DRY (Don't Repeat Yourself) principle
- Follow SOLID principles
- Keep functions short and readable (single responsibility)
- Write self-documenting code with clear variable/function names
- Avoid premature optimization
- No emoji in comments
- No placeholder comments like "Add this line"
- Write production-ready code always; avoid comments like "would be implemented in a real app"

### Code Reviews
- Check for TypeScript errors before committing
- Ensure no linter warnings
- Verify app builds on both iOS and Android
- Test on physical devices when possible

## Dependencies

### Package Management
- Keep dependencies up to date
- Review package.json regularly for unused dependencies
- Use specific version numbers, avoid wildcards
- Document why each major dependency was chosen
- Test thoroughly after updating React Native version

## Security

### Best Practices
- Never hardcode API keys, tokens, or secrets
- Validate all user inputs
- Sanitize data before displaying
- Use HTTPS for all network requests
- Implement proper authentication and authorization
- Keep sensitive data encrypted

## Performance Optimization

### React Native Performance
- Use Hermes engine (already configured)
- Profile with React DevTools and Flipper
- Optimize bundle size
- Use ProGuard/R8 for Android release builds
- Lazy load screens and heavy components
- Minimize bridge communication between JS and native

## Documentation

### Code Documentation
- Document complex logic with clear comments
- Keep README.md up to date
- No additional markdown files beyond README.md
- Document setup steps for new developers
- Maintain changelog for significant updates

## Fitness App Best Practices

### Workout Tracking
- Implement proper timer functionality with background support
- Handle app backgrounding during active workouts
- Save workout progress frequently to prevent data loss
- Support workout history and analytics

### User Experience
- Provide clear feedback for all user actions
- Implement smooth animations and transitions
- Handle loading states gracefully
- Support offline mode for core features
- Allow easy data entry during workouts

### Data Visualization
- Use charts/graphs for progress tracking
- Show meaningful statistics and trends
- Make historical data easily accessible
- Provide export functionality for user data

## Final Notes
- Always think about what other methods and areas might be affected by code changes
- Focus only on code relevant to the current task
- Avoid making major architectural changes to working features without explicit instruction
- Never change UI/UX without asking first
- When in doubt, ask for clarification rather than making assumptions

